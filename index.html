<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Winions Collage Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Courier Prime', monospace;
            color: #fff;
        }
        
        * {
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // Icon components
        const Download = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
            </svg>
        );

        const RotateCw = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
        );

        const ZoomIn = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v6m3-3H7" />
            </svg>
        );

        const ZoomOut = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7" />
            </svg>
        );

        const Trash = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
            </svg>
        );

        const RotateHandle = ({ className }) => (
            <svg className={className} fill="currentColor" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="2" fill="none"/>
                <path d="M12 2 L12 6 M12 18 L12 22 M2 12 L6 12 M18 12 L22 12" stroke="currentColor" strokeWidth="2"/>
            </svg>
        );

        const Shuffle = ({ className }) => (
            <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
        );

        function WinionsCollageGenerator() {
            const [elements, setElements] = useState([]);
            const [selectedId, setSelectedId] = useState(null);
            const [topText, setTopText] = useState('');
            const [bottomText, setBottomText] = useState('');
            const [isDragging, setIsDragging] = useState(false);
            const [isRotating, setIsRotating] = useState(false);
            const [isPinching, setIsPinching] = useState(false);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [initialPinchDistance, setInitialPinchDistance] = useState(0);
            const [initialScale, setInitialScale] = useState(1);
            const canvasRef = useRef(null);

            // Calculate distance between two touch points
            const getTouchDistance = (touch1, touch2) => {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            };

            // Bring element to foreground when selected
            const bringToFront = (id) => {
                setElements(prevElements => {
                    const maxZIndex = Math.max(...prevElements.map(el => el.zIndex), 0);
                    return prevElements.map(el => 
                        el.id === id ? { ...el, zIndex: maxZIndex + 1 } : el
                    );
                });
            };

            // Send element to background
            const sendToBack = () => {
                if (!selectedId) return;
                setElements(prevElements => {
                    const minZIndex = Math.min(...prevElements.map(el => el.zIndex), 0);
                    return prevElements.map(el => 
                        el.id === selectedId ? { ...el, zIndex: minZIndex - 1 } : el
                    );
                });
            };

            // Your Winion GIFs - matching actual GitHub file structure
            const winionsCollection = [
                '/winions/General hologram-min.gif',
                '/winions/clay-min.gif',
                '/winions/frog-min.gif',
                '/winions/gold general-min.gif',
                '/winions/gold-min.gif',
                '/winions/havoc-min.gif',
                '/winions/hellish-min.gif',
                '/winions/hologram-min.gif',
                '/winions/misfit-min.gif',
                '/winions/royal-min.gif',
                '/winions/shadow-min.gif',
                '/winions/spectrum-min.gif',
                '/winions/stencil-min.gif',
                '/winions/theory-min.gif',
                // '/winions/unknown-min.gif', // Commented out - broken link
            ];

            const memeTexts = [
                { top: 'WHEN THE BLOCKCHAIN', bottom: 'CALLS YOUR NAME' },
                { top: 'POV:', bottom: 'YOU FOUND A WINION' },
                { top: 'NOBODY:', bottom: 'WINIONS:' },
                { top: 'ME: *VIBING*', bottom: 'WINIONS: "HI"' },
                { top: 'THIS IS FINE', bottom: 'EVERYTHING IS FINE' },
                { top: 'RARE WINION', bottom: 'ACQUIRED' },
                { top: 'WHEN YOU', bottom: 'MINT AT 3AM' },
                { top: 'LEGENDARY DROP', bottom: 'INCOMING' },
            ];

            const getRandomText = () => {
                const random = memeTexts[Math.floor(Math.random() * memeTexts.length)];
                setTopText(random.top);
                setBottomText(random.bottom);
            };

            const addWinion = (src) => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const bounds = canvas.getBoundingClientRect();
                const maxSize = 180;
                const size = Math.random() * 80 + 100; // 100-180px
                
                // Keep well within bounds
                const x = Math.random() * (bounds.width - maxSize - 40) + 20;
                const y = Math.random() * (bounds.height - maxSize - 140) + 100; // Account for text
                
                setElements([...elements, {
                    id: Date.now(),
                    src,
                    x,
                    y,
                    rotation: 0,
                    scale: 1,
                    size,
                    zIndex: elements.length
                }]);
            };

            const randomize = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const bounds = canvas.getBoundingClientRect();
                const count = Math.floor(Math.random() * 4) + 3; // 3-6 Winions
                const newElements = [];
                
                for (let i = 0; i < count; i++) {
                    const src = winionsCollection[Math.floor(Math.random() * winionsCollection.length)];
                    const maxSize = 180;
                    const size = Math.random() * 80 + 100;
                    const x = Math.random() * (bounds.width - maxSize - 40) + 20;
                    const y = Math.random() * (bounds.height - maxSize - 140) + 100;
                    
                    newElements.push({
                        id: Date.now() + i,
                        src,
                        x,
                        y,
                        rotation: Math.random() * 360,
                        scale: Math.random() * 0.5 + 0.75, // 0.75-1.25
                        size,
                        zIndex: i
                    });
                }
                
                setElements(newElements);
                getRandomText();
            };

            const handleMouseDown = (e, id) => {
                e.preventDefault();
                const element = elements.find(el => el.id === id);
                if (!element) return;
                
                // Bring to foreground immediately
                bringToFront(id);
                setSelectedId(id);
                
                // Check for pinch gesture (2 fingers on touch)
                if (e.type === 'touchstart' && e.touches.length === 2) {
                    setIsPinching(true);
                    const distance = getTouchDistance(e.touches[0], e.touches[1]);
                    setInitialPinchDistance(distance);
                    setInitialScale(element.scale);
                    return;
                }
                
                const canvas = canvasRef.current.getBoundingClientRect();
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                
                setIsDragging(true);
                setDragOffset({
                    x: clientX - canvas.left - element.x,
                    y: clientY - canvas.top - element.y
                });
            };

            const handleRotateMouseDown = (e, id) => {
                e.preventDefault();
                e.stopPropagation();
                bringToFront(id);
                setSelectedId(id);
                setIsRotating(true);
            };

            const handleMouseMove = (e) => {
                if ((!isDragging && !isRotating && !isPinching) || selectedId === null) return;
                e.preventDefault();
                
                const element = elements.find(el => el.id === selectedId);
                if (!element) return;
                
                // Handle pinch-to-zoom
                if (isPinching && e.type === 'touchmove' && e.touches.length === 2) {
                    const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
                    const scaleChange = currentDistance / initialPinchDistance;
                    const newScale = Math.max(0.3, Math.min(2, initialScale * scaleChange));
                    
                    setElements(elements.map(el => 
                        el.id === selectedId ? { ...el, scale: newScale } : el
                    ));
                    return;
                }
                
                const canvas = canvasRef.current.getBoundingClientRect();
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                
                if (isRotating) {
                    // Calculate angle from element center to mouse position
                    const elementCenterX = canvas.left + element.x + (element.size * element.scale) / 2;
                    const elementCenterY = canvas.top + element.y + (element.size * element.scale) / 2;
                    
                    const angle = Math.atan2(
                        clientY - elementCenterY,
                        clientX - elementCenterX
                    ) * (180 / Math.PI) + 90; // +90 to align with top
                    
                    setElements(elements.map(el => 
                        el.id === selectedId ? { ...el, rotation: angle } : el
                    ));
                } else if (isDragging) {
                    let newX = clientX - canvas.left - dragOffset.x;
                    let newY = clientY - canvas.top - dragOffset.y;
                    
                    // Boundary constraints
                    const maxSize = element.size * element.scale;
                    newX = Math.max(0, Math.min(newX, canvas.width - maxSize));
                    newY = Math.max(60, Math.min(newY, canvas.height - maxSize - 60));
                    
                    setElements(elements.map(el => 
                        el.id === selectedId ? { ...el, x: newX, y: newY } : el
                    ));
                }
            };

            const handleMouseUp = () => {
                setIsDragging(false);
                setIsRotating(false);
                setIsPinching(false);
            };

            useEffect(() => {
                if (isDragging || isRotating || isPinching) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                    window.addEventListener('touchmove', handleMouseMove, { passive: false });
                    window.addEventListener('touchend', handleMouseUp);
                    
                    return () => {
                        window.removeEventListener('mousemove', handleMouseMove);
                        window.removeEventListener('mouseup', handleMouseUp);
                        window.removeEventListener('touchmove', handleMouseMove);
                        window.removeEventListener('touchend', handleMouseUp);
                    };
                }
            }, [isDragging, isRotating, isPinching, selectedId, dragOffset, elements, initialPinchDistance, initialScale]);

            // Deselect when clicking outside canvas
            useEffect(() => {
                const handleClickOutside = (e) => {
                    const canvas = canvasRef.current;
                    if (canvas && !canvas.contains(e.target)) {
                        setSelectedId(null);
                    }
                };

                document.addEventListener('mousedown', handleClickOutside);
                document.addEventListener('touchstart', handleClickOutside);

                return () => {
                    document.removeEventListener('mousedown', handleClickOutside);
                    document.removeEventListener('touchstart', handleClickOutside);
                };
            }, []);

            const selectedElement = elements.find(el => el.id === selectedId);

            const updateSelected = (updates) => {
                setElements(elements.map(el => 
                    el.id === selectedId ? { ...el, ...updates } : el
                ));
            };

            const rotateSelected = (degrees) => {
                if (!selectedElement) return;
                updateSelected({ rotation: (selectedElement.rotation + degrees) % 360 });
            };

            const scaleSelected = (delta) => {
                if (!selectedElement) return;
                const newScale = Math.max(0.3, Math.min(2, selectedElement.scale + delta));
                updateSelected({ scale: newScale });
            };

            const deleteSelected = () => {
                setElements(elements.filter(el => el.id !== selectedId));
                setSelectedId(null);
            };

            const exportImage = async () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                html2canvas(canvas, {
                    backgroundColor: '#000000',
                    scale: 2,
                    logging: false
                }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = 'winions-collage.png';
                    link.href = canvas.toDataURL();
                    link.click();
                });
            };

            return (
                <div className="min-h-screen bg-black p-4">
                    <div className="max-w-4xl mx-auto">
                        {/* Header */}
                        <div className="text-center mb-6">
                            <h1 className="text-4xl font-bold text-red-500 mb-2">WINIONS COLLAGE</h1>
                            <p className="text-gray-400">GENERATOR</p>
                        </div>

                        {/* Canvas */}
                        <div 
                            ref={canvasRef}
                            className="relative w-full bg-black border-2 border-gray-800 mb-4 overflow-hidden"
                            style={{ 
                                height: '600px',
                                maxHeight: '80vh',
                                touchAction: 'none'
                            }}
                            onClick={(e) => {
                                // Deselect if clicking directly on canvas background
                                if (e.target === canvasRef.current) {
                                    setSelectedId(null);
                                }
                            }}
                        >
                            {/* Top Text */}
                            {topText && (
                                <div className="absolute top-4 left-0 right-0 text-center z-50">
                                    <p className="text-white font-black uppercase tracking-wider px-2"
                                       style={{ 
                                           fontSize: '2.5rem',
                                           lineHeight: '1.1',
                                           fontFamily: 'Impact, "Arial Black", sans-serif',
                                           textShadow: `
                                               -3px -3px 0 #000,
                                               3px -3px 0 #000,
                                               -3px 3px 0 #000,
                                               3px 3px 0 #000,
                                               -4px 0 0 #000,
                                               4px 0 0 #000,
                                               0 -4px 0 #000,
                                               0 4px 0 #000,
                                               -2px -2px 0 #000,
                                               2px -2px 0 #000,
                                               -2px 2px 0 #000,
                                               2px 2px 0 #000
                                           `,
                                           WebkitTextStroke: '2px black'
                                       }}>
                                        {topText}
                                    </p>
                                </div>
                            )}

                            {/* Elements */}
                            {elements.map((element) => (
                                <div 
                                    key={element.id} 
                                    className="absolute"
                                    style={{
                                        left: `${element.x}px`,
                                        top: `${element.y}px`,
                                        width: `${element.size}px`,
                                        height: `${element.size}px`,
                                        zIndex: element.zIndex,
                                        pointerEvents: 'auto'
                                    }}
                                >
                                    <img
                                        src={element.src}
                                        alt="Winion"
                                        className={`cursor-move select-none ${selectedId === element.id ? 'ring-2 ring-red-500' : ''}`}
                                        style={{
                                            width: '100%',
                                            height: '100%',
                                            transform: `rotate(${element.rotation}deg) scale(${element.scale})`,
                                            transformOrigin: 'center'
                                        }}
                                        onMouseDown={(e) => handleMouseDown(e, element.id)}
                                        onTouchStart={(e) => handleMouseDown(e, element.id)}
                                        draggable={false}
                                    />
                                    
                                    {/* Rotation Handle - appears above selected element */}
                                    {selectedId === element.id && (
                                        <div
                                            className="absolute cursor-grab active:cursor-grabbing"
                                            style={{
                                                left: '50%',
                                                top: '-40px',
                                                transform: 'translateX(-50%)',
                                                zIndex: 999
                                            }}
                                            onMouseDown={(e) => handleRotateMouseDown(e, element.id)}
                                            onTouchStart={(e) => handleRotateMouseDown(e, element.id)}
                                        >
                                            <div className="w-8 h-8 bg-red-500 rounded-full flex items-center justify-center border-2 border-white shadow-lg">
                                                <RotateCw className="w-4 h-4 text-white" />
                                            </div>
                                            {/* Line connecting handle to element */}
                                            <div className="absolute top-8 left-1/2 transform -translate-x-1/2 w-0.5 h-8 bg-red-500"></div>
                                        </div>
                                    )}
                                </div>
                            ))}

                            {/* Bottom Text */}
                            {bottomText && (
                                <div className="absolute bottom-4 left-0 right-0 text-center z-50">
                                    <p className="text-white font-black uppercase tracking-wider px-2"
                                       style={{ 
                                           fontSize: '2.5rem',
                                           lineHeight: '1.1',
                                           fontFamily: 'Impact, "Arial Black", sans-serif',
                                           textShadow: `
                                               -3px -3px 0 #000,
                                               3px -3px 0 #000,
                                               -3px 3px 0 #000,
                                               3px 3px 0 #000,
                                               -4px 0 0 #000,
                                               4px 0 0 #000,
                                               0 -4px 0 #000,
                                               0 4px 0 #000,
                                               -2px -2px 0 #000,
                                               2px -2px 0 #000,
                                               -2px 2px 0 #000,
                                               2px 2px 0 #000
                                           `,
                                           WebkitTextStroke: '2px black'
                                       }}>
                                        {bottomText}
                                    </p>
                                </div>
                            )}

                            {/* Watermark */}
                            <div className="absolute bottom-2 right-2 text-red-500 text-xs opacity-50 z-50">
                                WINIONS.XYZ
                            </div>
                        </div>

                        {/* Element Controls */}
                        {selectedElement && (
                            <div className="mb-4 p-4 border-2 border-red-500 bg-gray-900">
                                <div className="flex items-center justify-between mb-2">
                                    <div>
                                        <span className="text-red-500 font-bold">SELECTED WINION</span>
                                        <span className="ml-2 text-gray-500 text-xs">
                                            Layer: {selectedElement.zIndex}
                                        </span>
                                    </div>
                                    <button
                                        onClick={deleteSelected}
                                        className="p-2 bg-red-600 hover:bg-red-700 text-white rounded"
                                    >
                                        <Trash className="w-4 h-4" />
                                    </button>
                                </div>
                                
                                <div className="mb-3 p-2 bg-black border border-gray-800 text-gray-400 text-xs">
                                    💡 Tap any Winion to bring it to the front
                                </div>
                                
                                <div className="grid grid-cols-2 gap-4">
                                    {/* Rotation */}
                                    <div>
                                        <label className="text-gray-400 text-sm mb-2 block">ROTATE</label>
                                        <div className="flex gap-2">
                                            <button
                                                onClick={() => rotateSelected(-15)}
                                                className="flex-1 p-2 bg-black border border-gray-700 text-white hover:border-red-500"
                                            >
                                                -15°
                                            </button>
                                            <button
                                                onClick={() => rotateSelected(15)}
                                                className="flex-1 p-2 bg-black border border-gray-700 text-white hover:border-red-500"
                                            >
                                                +15°
                                            </button>
                                        </div>
                                        <p className="text-center text-gray-500 text-xs mt-1">
                                            {Math.round(selectedElement.rotation)}°
                                        </p>
                                    </div>

                                    {/* Scale */}
                                    <div>
                                        <label className="text-gray-400 text-sm mb-2 block">SIZE</label>
                                        <div className="flex gap-2">
                                            <button
                                                onClick={() => scaleSelected(-0.1)}
                                                className="flex-1 p-2 bg-black border border-gray-700 text-white hover:border-red-500"
                                            >
                                                <ZoomOut className="w-4 h-4 mx-auto" />
                                            </button>
                                            <button
                                                onClick={() => scaleSelected(0.1)}
                                                className="flex-1 p-2 bg-black border border-gray-700 text-white hover:border-red-500"
                                            >
                                                <ZoomIn className="w-4 h-4 mx-auto" />
                                            </button>
                                        </div>
                                        <p className="text-center text-gray-500 text-xs mt-1">
                                            {Math.round(selectedElement.scale * 100)}%
                                        </p>
                                    </div>
                                </div>
                                
                                {/* Layer Controls */}
                                <div className="mt-4">
                                    <button
                                        onClick={sendToBack}
                                        className="w-full p-2 bg-black border border-gray-700 text-white hover:border-red-500 text-sm"
                                    >
                                        ⬇️ SEND TO BACK
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Text Controls */}
                        <div className="mb-4 p-4 border border-gray-800 bg-gray-900">
                            <div className="flex justify-between items-center mb-2">
                                <h3 className="text-red-500 font-bold">TEXT</h3>
                                <button
                                    onClick={getRandomText}
                                    className="px-3 py-1 bg-black border border-gray-700 text-white text-sm hover:border-red-500"
                                >
                                    <Shuffle className="w-4 h-4 inline mr-1" />
                                    RANDOM
                                </button>
                            </div>
                            <input
                                type="text"
                                value={topText}
                                onChange={(e) => setTopText(e.target.value.toUpperCase())}
                                placeholder="TOP TEXT"
                                className="w-full p-2 mb-2 bg-black border border-gray-700 text-white placeholder-gray-600 focus:border-red-500 outline-none"
                            />
                            <input
                                type="text"
                                value={bottomText}
                                onChange={(e) => setBottomText(e.target.value.toUpperCase())}
                                placeholder="BOTTOM TEXT"
                                className="w-full p-2 bg-black border border-gray-700 text-white placeholder-gray-600 focus:border-red-500 outline-none"
                            />
                        </div>

                        {/* Action Buttons */}
                        <div className="grid grid-cols-3 gap-2 mb-4">
                            <button
                                onClick={randomize}
                                className="p-3 bg-red-600 hover:bg-red-700 text-white font-bold"
                            >
                                RANDOMIZE
                            </button>
                            <button
                                onClick={() => setElements([])}
                                className="p-3 bg-black border border-gray-700 text-white hover:border-red-500"
                            >
                                CLEAR
                            </button>
                            <button
                                onClick={exportImage}
                                className="p-3 bg-black border border-gray-700 text-white hover:border-red-500 flex items-center justify-center gap-2"
                            >
                                <Download className="w-4 h-4" />
                                EXPORT
                            </button>
                        </div>

                        {/* Winion Picker */}
                        <div className="border border-gray-800 p-4 bg-gray-900">
                            <h3 className="text-red-500 font-bold mb-3">ADD WINION</h3>
                            <div className="grid grid-cols-5 gap-2">
                                {winionsCollection.map((src, idx) => (
                                    <button
                                        key={idx}
                                        onClick={() => addWinion(src)}
                                        className="aspect-square border border-gray-700 hover:border-red-500 p-1 bg-black transition-all"
                                    >
                                        <img src={src} alt={`Winion ${idx + 1}`} className="w-full h-full object-contain" />
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<WinionsCollageGenerator />);
    </script>
</body>
</html>
